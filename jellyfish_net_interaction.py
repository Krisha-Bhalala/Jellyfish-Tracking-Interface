# -*- coding: utf-8 -*-
"""virtual_drag_drop.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mw09bHaBvIKvI0uIRIEKq3O_1IDUGWzF
"""

# Importing necessary libraries
from google.colab import files  # Used for uploading files in Google Colab
from IPython.display import HTML, display  # To display HTML content in Colab
import base64  # To encode image data into Base64 for embedding in HTML
import cv2  # OpenCV library for image processing
import numpy as np  # For numerical operations like creating blank canvas arrays

# Upload the image using Google Colab's file uploader
uploaded = files.upload()  # Opens a dialog to upload a file
filename = list(uploaded.keys())[0]  # Gets the name of the uploaded file

# Read and convert the image
image = cv2.imread(filename)  # Reads the uploaded image into OpenCV format (BGR)
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)  # Converts the image from BGR to RGB format

# Define sizes for the jellyfish image and the canvas
jellyfish_size = 100  # Desired size of the jellyfish image (maximum dimension in pixels)
canvas_size = 400  # Dimensions of the canvas (400x400 pixels)

# Calculate the aspect ratio of the image for proper resizing
aspect_ratio = image.shape[1] / image.shape[0]  # Width divided by height
if aspect_ratio > 1:  # If the image is wider than it is tall
    new_width = jellyfish_size  # Set the width to the bee size
    new_height = int(jellyfish_size / aspect_ratio)  # Calculate height while maintaining aspect ratio
else:  # If the image is taller than it is wide
    new_height = jellyfish_size  # Set the height to the jellyfish size
    new_width = int(jellyfish_size * aspect_ratio)  # Calculate width while maintaining aspect ratio

# Resize the image to fit within the jellyfish_size constraints
image = cv2.resize(image, (new_width, new_height))  # Resize the image to (new_width, new_height)

# Create a blank white canvas
canvas = np.ones((canvas_size, canvas_size, 3), dtype=np.uint8) * 255  # A white canvas of size 400x400

# Calculate the position to center the resized image on the canvas
y_offset = (canvas_size - new_height) // 2  # Vertical offset for centering
x_offset = (canvas_size - new_width) // 2  # Horizontal offset for centering

# Place the resized bee image onto the center of the canvas
canvas[y_offset:y_offset+new_height, x_offset:x_offset+new_width] = image  # Overlay the image

# Convert the canvas to Base64 format for embedding in HTML
_, buffer = cv2.imencode('.png', canvas)  # Encode the canvas as a PNG image
img_base64 = base64.b64encode(buffer).decode('utf-8')  # Encode the image as a Base64 string

# HTML and JavaScript for displaying the canvas and adding interactivity
html_content = f"""
<canvas id="canvas" width="{canvas_size}" height="{canvas_size}" style="border:1px solid #000000;"></canvas>
<p id="message"></p>
<script>
    var canvas = document.getElementById('canvas');  // Get the canvas element
    var ctx = canvas.getContext('2d');  // Get the 2D drawing context for the canvas
    var img = new Image();  // Create a new image element
    img.onload = function() {{
        ctx.drawImage(img, 0, 0, {canvas_size}, {canvas_size});  // Draw the image on the canvas
        drawRect();  // Draw the rectangle overlay
    }};
    img.src = 'data:image/png;base64,{img_base64}';  // Set the image source to the Base64 data

    // Define a rectangle (representing a "net") to interact with the image
    var rect = {{ x: 150, y: 150, width: 150, height: 150 }};  // Initial position and size of the rectangle
    var dragging = false;  // Flag to track if the rectangle is being dragged
    var startX, startY;  // Variables to store the starting mouse position

    // Function to draw the rectangle on the canvas
    function drawRect() {{
        ctx.beginPath();  // Start a new path
        ctx.rect(rect.x, rect.y, rect.width, rect.height);  // Draw the rectangle
        ctx.strokeStyle = 'red';  // Set the border color to red
        ctx.lineWidth = 2;  // Set the border thickness
        ctx.stroke();  // Render the rectangle outline
        checkOverlap();  // Check if the rectangle overlaps with the bee image
    }}

    // Function to check if the rectangle overlaps with the image
    function checkOverlap() {{
        var centerX = rect.x + rect.width / 2;  // Calculate the rectangle's center X coordinate
        var centerY = rect.y + rect.height / 2;  // Calculate the rectangle's center Y coordinate
        var imgData = ctx.getImageData(centerX, centerY, 1, 1);  // Get the pixel data at the center
        var pixel = imgData.data;  // Extract the RGBA values of the pixel
        var message = document.getElementById('message');  // Get the message element
        if (pixel[0] !== 255 || pixel[1] !== 255 || pixel[2] !== 255) {{  // Check if the pixel is not white
            message.textContent = "Jellyfish in the net!";  // Display message if the rectangle overlaps the bee
        }} else {{
            message.textContent = "Jellyfish out of net!";  // Display message if the rectangle doesn't overlap
        }}
    }}

    // Event listener for starting the drag
    canvas.addEventListener('mousedown', function(e) {{
        startX = e.clientX - canvas.offsetLeft;  // Calculate the mouse X position relative to the canvas
        startY = e.clientY - canvas.offsetTop;  // Calculate the mouse Y position relative to the canvas
        // Check if the mouse is inside the rectangle
        if (startX >= rect.x && startX <= rect.x + rect.width &&
            startY >= rect.y && startY <= rect.y + rect.height) {{
            dragging = true;  // Set the dragging flag to true
        }}
    }});

    // Event listener for dragging the rectangle
    canvas.addEventListener('mousemove', function(e) {{
        if (dragging) {{  // If dragging is active
            var mouseX = e.clientX - canvas.offsetLeft;  // Get the current mouse X position
            var mouseY = e.clientY - canvas.offsetTop;  // Get the current mouse Y position
            var dx = mouseX - startX;  // Calculate the change in X position
            var dy = mouseY - startY;  // Calculate the change in Y position
            rect.x += dx;  // Update the rectangle's X position
            rect.y += dy;  // Update the rectangle's Y position
            startX = mouseX;  // Update the starting X position for the next move
            startY = mouseY;  // Update the starting Y position for the next move
            ctx.clearRect(0, 0, canvas.width, canvas.height);  // Clear the canvas
            ctx.drawImage(img, 0, 0, {canvas_size}, {canvas_size});  // Redraw the image
            drawRect();  // Redraw the rectangle
        }}
    }});

    // Event listener for ending the drag
    canvas.addEventListener('mouseup', function(e) {{
        dragging = false;  // Set the dragging flag to false
    }});
</script>
"""

# Display the interactive canvas in the notebook
display(HTML(html_content))  # Render the HTML and JavaScript in the output cell
